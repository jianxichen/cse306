For this task, I essentially modified files vm.c and kalloc.c. This is because most of what needed to be done required changes to the methods of allocating user program memory (in forms of a page table). To be precise, for Copy-on-Write implementation, whenever there's a fork() syscall, instead of allocating the child process it's own user space memory right away, we will hold that off until the child (or parent) process decides to write into the shared page table memory and instead will give the child process the page table directory reference of the parent's while setting that page directory entries on Read-Only. When a process attempts to write into the shared page table memory, it will cause a pagefault because the particular set of page tables entries are not writable (in read only mode). This then signals a pagefault and builds the trapframe. 

I used an array as my "coremap" to keep track of the page tables entries allocated with the purpose of keeping reference counts of each Page Table entry. The indexes for the array are relative to the allocateable Physical Page Number (PPN) in memory. For example, since we know that the peak of physical memory is PHYSTOP, this means we would have PHYSTOP>>12 = PHYSTOP/4096 unique page table addresses. This also means the array size of the coremap is size PHYSTOP>>12. For every allocated Page Table Entry, we will obtain the PPN within the PTE, find its relative spot in the coremap, and increment the reference count; if we're deallocating the Page Table Entry, we will decrement it. To keep track of the increments and decrements, I added a tracking variable in kalloc.c for the purpose of tracking allocated PTEs. I also added a getter and setter function for that variable with locks to ensure there will be no overwrites for the tracking variable. In addition, I added another tracking variable for the purpose of kalloc() and kfree() in order to see the amount of pages used (that also includes Page Table Directories and etc). Most of the inrecrementing and decrementing are being used in vm.c but I thought it was rather appropriate for it to be declared in kalloc.c because there is where the kinits are defined which I thought is a good place to start defining the locks for these tracking variables and etc.

When a PTE reaches a reference count of 0, it must be deallocated. In order to implement this, I modified the function deallocuvm() to just decrement the reference count of it has any and then deallocate the PTE if there are no more references to that PTE, just like what it had done in the original function. With the modification of deallocuvm(), I also modifed allocuvm by adding the reference counting setters functions in it so that allocuvm() will also increment Page Table Entry references as it properly should. 

For my particular pagefault handler, I modified the function copyuvm to have an additional function argument in order to provide both reference copy and deep memory copy (like the original). In the syscall function fork(), that would pass the argument to make a reference copy, but in the page handler, it would be passed the argument to make a deep (memory) copy (with new set of allocations). Also within my page handler, I also included a deallocuvm() at the end. This is because the way I modified copyuvm() is so it would only increase the reference count of the newly allocated Page Table entries (cause I believed that copying shouldn't need to think about decrementing references), and the decrementing would be left by deallocuvm(). This is because since deallocuvm() would not free Page Table Entries unless reference count=0, so it basically covers the basis of what's needed to be done which is +1 to new entries and -1 to old enties, and dealloc if old entries have reference count=0.

In my user program "pagetest", I first declared an array of size 2000 ints, which is larger than a PGSIZE, and then calling 2 separate fork()s per each iteration for "#define PROCNUM" iterations. The first fork() has child process writing into the array before sleeping and exiting meanwhile the second fork() has the child do nothing before sleeping and exiting. One weird that I found was that xv6 calls for a page fault even when there isn't a sort of Writing. For example, I tried the a set of code with just fork()ing and then exit()ing for both parent and child but even then there exists a pagefault signal which was weird and interesting.